#Боритесь со сложностью

Разделите систему на подсистемы на уровне архитектуры, чтобы концентрироваться в каждый конкретный момент времени на меньшей части системы.
Тщательно определяйте интерфейсы классов, чтобы можно было игнорировать внутреннее устройство классов.
Поддерживайте абстракцию, формируемую интерфейсом класса, чтобы не запоминать ненужных деталей.
Избегайте глобальных данных, потому что их использование значительно увеличивает процент кода, который нужно удерживать в уме в любой момент времени.
Избегайте глубоких иерархий наследования, потому что они предъявляют высокие требования к интеллекту.
Избегайте глубокой вложенности циклов и условных операторов, поскольку их можно заменить на более простые управляющие структуры, позволяющие бережнее расходовать умственные ресурсы.
Избегайте операторов goto, так как они вносят в программу нелинейность, за которой большинству людей трудно следовать.
Тщательное определите подход к обработке ошибок, вместо того чтобы использовать произвольную комбинацию разных методик.
Систематично используйте встроенный механизм исключений, поскольку он может стать нелинейной управляющей структурой, которую при недисциплинированном применении понять почти так же трудно, как и операторы goto.
Не позволяйте классам превращаться в монстров, достигающих размера целых программ.
Поддерживайте методы короткими.
Используйте ясные, очевидные имена переменных, чтобы не вспоминать детали вроде «i — это индекс счета, а j — индекс клиента или наоборот?».
Минимизируйте число параметров, передаваемых в метод, или, что еще важнее, передавайте только те параметры, которые нужны для поддержания абстракции, формируемой интерфейсом метода.
Используйте соглашения, чтобы не запоминать произвольные, несущественные различия между разными фрагментами кода.
Проектирование качественных классов

#Классы должны быть компактными
Классы должны иметь одну ответственность, то есть одну причину для изменений — SRP.
Связность класса должна быть высокой. Высокая связность означает, что методы и переменные класса взаимозависимы и существуют как единое целое.
Выражайте в интерфейсе класса согласованный уровень абстракции.
Предоставляйте методы вместе с противоположными им методами.
Убирайте постороннюю информацию в другие классы.
По мере возможности делайте интерфейсы программными, а не семантическими. Старайтесь преобразовывать семантические элементы интерфейса в программные, используя утверждения (assertions) или иными способами.
Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса.
Не делайте предположений о клиентах класса. Класс следует спроектировать и реализовать так, чтобы он придерживался контракта, сформулированного посредством интерфейса.
Цените легкость чтения кода выше, чем удобство его написания.
Разумные причины создания классов

Моделирование объектов реального мира
Моделирование абстрактных объектов
Снижение сложности
Сокрытие деталей реализации
Ограничение влияния изменений. Изолируйте области вероятных изменений, чтобы влияние изменений ограничивалось пределами одного или нескольких классов.
Сокрытие глобальных данных
Упрощение передачи параметров в методы
Создание центральных точек управления
Облегчение повторного использования кода
Упаковка родственных операций
Проектирование качественных функций и методов

#Функции должны быть компактными. Не больше 20 строк.
Блоки в командах if, else, while и т.д. должны состоять из одной строки, в которой обычно содержится вызов функции.
Максимальный уровень отступов в функции не должен превышать 1-2.
Стремитесь, чтобы функция содержала не более 2х параметров.
Функция должна выполнять только одну операцию.Она должна выполнять ее хорошо. И ничего другого она делать не должна.
Настороженно относитесь к параметрам-флагам. Их наличие говорит о том, что функция делает как минимум две операции.
Один уровень абстракции на функцию — все команды функции находятся на одном уровне абстракции.
Чтение кода сверху вниз: правило понижения. Код должен читаться как рассказ — сверху вниз.
За каждой функцией должны следовать функции следующего уровня абстракции. Это позволяет читать код, последовательно спускаясь по уровням абстракции в ходе чтения списка функций.
Разделение команд и запросов (CQRS). Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние объекта, либо возвращает информацию об этом объекте. Совмещение двух операций часто создает путаницу.
Используйте исключения вместо возвращения кодов ошибок. Возвращение кодов ошибок — нарушение принципа CQRS.
Изолируйте блоки try/catch. Тела этих блоков рекомендуется выделять в отдельные функции.
Не возвращайте null. Не передавайте null.
Разумные причины создания методов

#Снижение сложности
Формирование понятной промежуточной абстракции
Предотвращение дублирования кода
Поддержка наследования
Сокрытие очередности действий
Улучшение портируемости
Упрощение сложных булевых проверок
Повышение быстродействия